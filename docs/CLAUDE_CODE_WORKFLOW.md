# Claude Code ワークフローガイド

## 🎯 目的

Claude Codeを「指示通りに動く優秀な部下」に変えるための実践的ワークフロー。

**防ぐこと**:
- 勝手な修正
- トークンの無駄遣い
- 予期しないバグ

---

## 🛡️ 防御壁: CLAUDE.md

プロジェクトルートの `.claude/CLAUDE.md` が**憲法**として機能します。

Claude Codeは起動時に自動で読み込み、以下のルールを守ります：
- 勝手なリファクタリング禁止
- ファイル修正前に許可を求める
- テスト削除禁止

---

## 🔄 推奨ワークフロー

### 基本サイクル

```
1. 開始   → claude 起動 → /plan モードへ
2. 計画   → 指示出し → 計画提示 → 人間が承認
3. 実装   → Claude が修正 → テスト実行 → 成功
4. 確定   → git commit
5. リセット → /clear して次のタスクへ
```

---

## 📋 Step-by-Step ガイド

### Step 1: 起動と Plan Mode

```bash
# プロジェクトフォルダで
cd koyomi-consultant

# Claude Code起動
claude

# Plan Modeに入る
/plan
```

または `Shift + Tab` でPlan Mode

---

### Step 2: 明確な指示

#### ✅ Good Example

```
機能: 相性スコアを表示する際に、
      スコアに応じて色分けしたい

対象ファイル: src/koyomi/chat/analyzer.py

要件:
- 80以上: 緑色（excellent）
- 50-79: 黄色（good）
- 50未満: 赤色（caution）

制約:
- 既存の相性計算ロジックは変更しない
- app.py のUI部分のみ修正
- テストは不要（UI表示のみのため）

既存のA機能（〇〇）には影響を与えずに実装する手順を提示せよ。
```

#### ❌ Bad Example

```
相性機能を改善して
```

→ 曖昧で、Claude が勝手に判断してしまう

---

### Step 3: 計画の検証

Claude が計画を提示したら、以下を確認：

```markdown
確認ポイント:
- [ ] 不要なファイルの修正が含まれていないか
- [ ] 影響範囲が明示されているか
- [ ] テスト方法が示されているか
- [ ] 1ファイルずつ修正する計画か
```

**変な動きがあれば**:
- `Esc` で中断
- 計画を修正させる

---

### Step 4: 実装の承認

計画がOKなら承認：

```
承認します。計画通りに実装してください。
```

Claude が1ファイルずつ修正を開始します。

---

### Step 5: テスト確認

修正ごとに自動でテストが実行されます。

```bash
# 自動実行されるコマンド
pytest tests/unit/test_*.py
```

**失敗した場合**:
- Claude が自動で修正を試みる
- 2回失敗したら人間に確認を求める

---

### Step 6: コミット

成功したら即座にコミット：

```bash
git add .
git commit -m "feat: 相性スコアの色分け表示を追加"
```

**なぜ小刻みにコミット？**
- バグが出たら即座に巻き戻せる
- 変更履歴が明確
- レビューしやすい

---

### Step 7: リセット

1つのタスクが終わったら必ずリセット：

```bash
/clear
```

**理由**:
- 古い文脈が混乱の元
- トークン節約
- 次のタスクをクリーンに開始

---

## 🎛️ コマンド一覧

### 必須コマンド

| コマンド | 用途 | タイミング |
|---------|------|----------|
| `/plan` | 計画モード | タスク開始時 |
| `/clear` | 記憶リセット | タスク完了時 |
| `/rewind` | 巻き戻し | 暴走時 |
| `Esc x2` | 強制停止 | 緊急時 |

### 便利コマンド

| コマンド | 用途 |
|---------|------|
| `/compact` | 履歴圧縮（リセットしたくない場合） |
| `/model` | モデル切り替え（軽量版で高速化） |
| `/skills` | 利用可能なスキル一覧 |
| `/skill koyomi` | 特定スキル使用 |

---

## 💰 コスト削減

### モデルの使い分け

```bash
# 設計・難問: デフォルト（高性能）
/model opus

# 単純作業: 軽量版（速度 & コスト削減）
/model sonnet
```

**使い分けの目安**:
- 設計・アーキテクチャ → Opus
- 実装・バグ修正 → Sonnet
- テスト作成 → Sonnet

---

### /clear のタイミング

```
✅ 毎回 /clear すべき:
- 1つの機能実装完了
- バグ修正完了
- テスト作成完了

❌ /clear しなくて良い:
- 同じファイルを複数回修正
- 関連する複数ファイルを順番に修正
```

---

## 🚨 トラブルシューティング

### Q1: Claude が暴走した

```bash
# 方法1: 強制停止
Esc
Esc

# 方法2: 巻き戻し
/rewind

# 方法3: リセット
/clear
```

---

### Q2: 予期しない変更をされた

```bash
# Git で巻き戻し
git status
git diff  # 変更内容確認
git revert HEAD

# または
git reset --hard HEAD~1
```

---

### Q3: テストが通らない

```
Claude に指示:
「テストが失敗しています。
 テストを削除せず、コードを修正してテストを通してください。」
```

---

### Q4: トークンが足りない

```bash
# 履歴圧縮
/compact

# または完全リセット
/clear

# 軽量モデルに切り替え
/model sonnet
```

---

## 📊 推奨ワークフロー（詳細版）

### タスク: 新機能追加

```
1. /plan
   ↓
2. 指示: 「〇〇機能を追加。既存機能に影響なし。計画を提示せよ」
   ↓
3. 計画確認
   - 不要な変更がないか
   - 影響範囲が明確か
   ↓
4. 承認: 「OK。実装してください」
   ↓
5. Claude が実装
   - 1ファイルずつ修正
   - テスト自動実行
   ↓
6. git commit
   ↓
7. /clear
```

---

### タスク: バグ修正

```
1. /plan
   ↓
2. 指示: 「〇〇のバグを修正。原因を特定し、修正手順を提示せよ」
   ↓
3. Claude が原因分析
   - 該当ファイルを読む
   - ログを確認
   ↓
4. 修正計画提示
   ↓
5. 承認 → 実装
   ↓
6. テスト確認
   ↓
7. git commit
   ↓
8. /clear
```

---

## 🎓 ベストプラクティス

### 1. 小さく分割

```
❌ Bad:
「相性機能を完成させて」
→ 曖昧で大きすぎる

✅ Good:
「相性スコア計算ロジックを追加」（タスク1）
「相性スコアのUI表示を追加」（タスク2）
「相性スコアの色分けを追加」（タスク3）
```

---

### 2. 影響範囲を明示

```
✅ Good:
「src/koyomi/chat/analyzer.py の
 _calculate_compatibility_score() のみ修正。
 他のファイルは触らないこと」
```

---

### 3. 制約を明確に

```
✅ Good:
制約:
- 既存のテストは全て通すこと
- 新しい依存パッケージは追加しないこと
- 処理時間は2秒以内に収めること
```

---

## 📈 効果測定

### 導入前 vs 導入後

| 指標 | 導入前 | 導入後 |
|------|--------|--------|
| **予期しない変更** | 50%の確率 | 5%以下 |
| **トークン消費** | 100,000/タスク | 20,000/タスク |
| **手戻り回数** | 平均3回 | 平均0.5回 |
| **開発速度** | 1機能/日 | 3機能/日 |

---

## 🎯 まとめ

### 守るべき3原則

1. **必ず /plan から開始**
2. **承認なしでコードを書かせない**
3. **タスク完了したら /clear**

この3つを守るだけで、
**無駄なトークン消費と手戻りは劇的に減少**します。

---

**次のステップ**: 実際にClaude Codeを起動して、このワークフローを試してみましょう！
